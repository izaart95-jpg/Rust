name: Windows Cloudflared Keep Alive

on:
  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:
  # Optional: Schedule to run automatically (e.g., every day at midnight UTC)
  # schedule:
  #   - cron: '0 0 * * *'

jobs:
  keep-alive:
    runs-on: windows-latest
    
    # Set a higher timeout if needed (Max is 6 hours = 360 minutes)
    timeout-minutes: 360

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Start Cloudflared Tunnel (Keep Alive)
        shell: powershell
        run: |
          $ErrorActionPreference = "Stop"
          
          # 1. Setup Workspace
          $desktop = "$env:USERPROFILE\Desktop"
          echo "DESKTOP_DIR=$desktop" >> $env:GITHUB_ENV
          cd $desktop

          # 2. Download Cloudflared
          Write-Host "Downloading cloudflared..."
          Invoke-WebRequest `
            -Uri "https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-windows-amd64.exe" `
            -OutFile "cloudflared.exe"

          Unblock-File "cloudflared.exe"
          echo "CLOUDFLARED_EXE=$desktop\cloudflared.exe" >> $env:GITHUB_ENV

          # 3. Start a Dummy Web Server (Crucial Step)
          # Cloudflared needs a target. We create a simple HTTP listener on port 8080.
          Write-Host "Starting dummy web server on port 8080..."
          $listenerJob = Start-Job -ScriptBlock {
              $listener = New-Object System.Net.HttpListener
              $listener.Prefixes.Add("http://localhost:8080/")
              $listener.Start()
              Write-Host "Dummy Server Started on port 8080"
              
              # Infinite loop to keep the server alive
              while ($listener.IsListening) {
                  $context = $listener.GetContext()
                  $response = $context.Response
                  $response.StatusCode = 200
                  # Return a simple HTML page so you know it's working
                  $html = "<html><body><h1>GitHub Actions Keep Alive</h1><p>Running from Windows Runner</p></body></html>"
                  $buffer = [System.Text.Encoding]UTF8.GetBytes($html)
                  $response.ContentLength64 = $buffer.Length
                  $response.OutputStream.Write($buffer, 0, $buffer.Length)
                  $response.OutputStream.Close()
              }
          }

          # 4. Start Cloudflared in Background
          $outFile = "$desktop\cloudflared_output.txt"
          echo "CLOUDFLARED_OUT=$outFile" >> $env:GITHUB_ENV

          $cloudflaredJob = Start-Job -ScriptBlock {
            param($exe, $out)
            # Redirect all output to file
            & $exe tunnel --url http://localhost:8080 *> $out
          } -ArgumentList "$desktop\cloudflared.exe", $outFile

          echo "CLOUDFLARED_JOB_ID=$($cloudflaredJob.Id)" >> $env:GITHUB_ENV

          # 5. Wait for initialization
          # Cloudflare usually takes 5-15 seconds to negotiate the tunnel
          Write-Host "Waiting for tunnel to initialize..."
          Start-Sleep -Seconds 15

          # 6. Detect URL using Regex
          $content = Get-Content $outFile -Raw
          
          # Regex matches: https://[alphanumeric-hyphens].trycloudflare.com
          $match = $content | Select-String -Pattern 'https://[a-z0-9-]+\.trycloudflare\.com'

          Write-Host ""
          Write-Host "========================================"
          Write-Host "   CLOUDFLARED TUNNEL ESTABLISHED"
          Write-Host "========================================"
          if ($match) {
            $url = $match.Matches[0].Value.Trim()
            Write-Host "TUNNEL URL: $url"
            
            # Mask the URL in logs to prevent it from being redacted/hidden by GitHub runners
            # (Sometimes GitHub auto-hides URLs that look like domains)
            Write-Host "::add-mask::$url"
            
            # Save to ENV so subsequent steps can use it
            echo "TUNNEL_URL=$url" >> $env:GITHUB_ENV
          } else {
            Write-Host "ERROR: Tunnel URL not detected."
            Write-Host "Cloudflared Output:"
            Write-Host $content
            exit 1
          }
          Write-Host "========================================"
          Write-Host ""

      - name: Hold Connection (Keep Job Alive)
        shell: powershell
        run: |
          Write-Host "Job is holding the tunnel open..."
          Write-Host "Visit the URL printed above."
          Write-Host "This loop will run indefinitely until the job is cancelled or times out (6h)."
          
          # Infinite loop to prevent the job from finishing
          while($true) { 
              Start-Sleep -Seconds 60 
              
              # Optional: Check if the cloudflared process is still running
              $jobId = $env:CLOUDFLARED_JOB_ID
              $job = Get-Job -Id $jobId -ErrorAction SilentlyContinue
              if ($job.State -ne 'Running') {
                  Write-Host "ERROR: Cloudflared job has stopped."
                  Receive-Job -Id $jobId
                  exit 1
              }
          }
